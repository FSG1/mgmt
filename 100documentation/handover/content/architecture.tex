% !TeX spellcheck = en_US

\chapter{Software Architecture}
\label{ch:architecture}

\section{Frontend}

For Frontend a group member did research in multiple technologies for front-end. Then in discussions that followed, the group voted for Angular for front-end. For more information see the research which can be found in the \href{https://github.com/FSG1/mgmt/tree/master/30analysis/frontend_frameworks}{"30analysis/frontend\_frameworks"} directory. There is also a page breakdown diagram and a page navigation diagram if one needs more information found in \href{https://github.com/FSG1/mgmt/tree/master/100documentation/frontend}{"100documentation/frontend"}.

\section{Backend}

As to lower the cost it is decided to use open source programming languages. The deployment environment supports open source as well. The deployment environment is a Linux server provided by the customer. In this light it is chosen that Java is used for back-end development. The group is well experienced with Java, which made a big impact on the choice as well. See the back-end research for more information found in \href{https://github.com/FSG1/mgmt/tree/master/30analysis/java_frameworks_backend}{"30analysis/java\_frameworks\_backend"} directory.

Furthermore a research was done on which frameworks to use in this project. From this research it was decided to use JDBC because complex query's are required. These are not possible with for example Hibernate. Furthermore it was decided that Jersey was to be used for the endpoints. The group preferred small frameworks over big frameworks that do more then one needs.

\section{Database}

To store the relational data, a PostgreSQL database is used. This decision was made by the customer because he already provided an engineered database when the project started.
Nevertheless PostgreSQL is a reasonable choice, it provides all necessary feature important for the project.

\section{Architectural decisions}

One of the big decisions made is that the littlest amount of endpoints on a page should be called as possible. The consequence of this is that we have few endpoints but many interfaces (object definitions). The communication between front-end and back-end is thus faster as result. If one is to look through the front-end interface one will see that we almost exclusively use interfaces instead of classes. This is done because creating an object adhering to an interface has a lower memory footprint.

For more information about the endpoints see the Software \href{https://github.com/FSG1/mgmt/blob/master/100documentation/Software\%20architecture\%20endpoints\%20aesthetic.pdf}{"architecture endpoints aesthetic.pdf"} document in the 100documentation directory.